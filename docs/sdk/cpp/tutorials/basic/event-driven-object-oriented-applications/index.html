<html>
<head>
<title>Event-Driven OO Applications</title>
</head>
<body>
<h1>Event-Driven OO Applications</h1>
<p>The <strong>MAUtil::Moblet</strong> C++ class provides boilerplate event handling and produces well-behaved, resource-efficient programs. It helps provide a higher-level abstraction of program flow.</p>
<p>
<!--break--></p>

<p>The <strong>MAUtil::Moblet</strong> class takes care of the application main loop for you. All you need to do is subclass it and implement virtual functions to respond to the events.</p>

<h2>Example: A Basic Moblet Application</h2>
<p>
<pre class="mosync-code-cpp">#include &lt;MAUtil/Moblet.h&gt;
using namespace MAUtil;
class MyMoblet : public Moblet {
public:
    MyMoblet() {
        // Application initialization
    }
    void keyPressEvent(int keyCode) {
        // Handle key presses here
    }
    void keyReleaseEvent(int keyCode) {
        // Handle key releases here
    }
private:
};
// Since this is a C++ program, the main function
// needs to be declared extern "C"
extern "C" int MAMain() {
    Moblet::run(new MyMoblet());
}
</pre>
</p>

<div class="code"><!-- temp.cpp : generated by JHighlight v(unknown version) (http://jhighlight.dev.java.net) --> <span class="cpp_preproc"> </span><span class="cpp_separator"> </span><span class="cpp_plain"> </span></div>

<p>The static function <strong>Moblet::run()</strong> implements the actual event loop. When it gets events, it distributes them to all registered listeners. The Moblet, being both a <strong>KeyListener</strong> and a <strong>CloseListener</strong>, will recieve these event types. It is recommended to handle other event types by letting your moblet inherit the corresponding listener types, such as <strong>BluetoothListener </strong>and <strong>ConnectionListener</strong>.</p>

<p>Working with connections in Moblet-based applications involves using the <strong>ConnectionListener </strong>interface. You inherit the class and implement the <strong>connEvent()</strong> function. You can use one listener for several connections, but each connection can only be associated with one listener. Once the events are received, you should process them in the same way as in the <a href="TEMPLATE_DOC_PATH/sdk/cpp/tutorials/basic/classic-procedural-applications/index.html">classic model</a>.</p>

<h2>Example: A Moblet Application Using Connections</h2>

<!-- temp.cpp : generated by JHighlight v(unknown version) (http://jhighlight.dev.java.net) --><p>
<pre class="mosync-code-cpp">#include &lt;conprint.h&gt;
#include &lt;MAUtil/Moblet.h&gt;
using namespace MAUtil;
class ConnMoblet : public Moblet, public ConnListener {
private:
    // Variables survive past individual function calls.
    char mBuffer[160];
    Handle mConn;
public:
    ConnMoblet() {
        // Application initialization goes here.
        InitConsole();
        ConsoleDelay = 0;
        ConsoleLogging = 1;
        // Create a connection.
        printf("Connecting...\n");
        mConn = maConnect("http://www.example.com/"); // Will cause a CONNECT event.
        // Register for events.
        setConnListener(mConn, this);
    }
    void closeConn() {
        maConnClose(mConn);
        removeConnListener(mConn);
    }
    void connEvent(const CONN_EVENT_DATA&amp; data) {
        if(data.opType == CONNOP_CONNECT) {
            // The Connect operation is complete.
            if(data.result &lt; 0) {
                printf("Connect error %i\n", data.result);
                closeConn();
            } else {
                printf("HTTP result %i\n", data.result);
                // Start reading data.
                maConnRead(mConn, mBuffer, sizeof(mBuffer) - 1); 
 // Will cause a CONN READ event.
            }
        } else if(data.opType == CONNOP_READ) {
            // The Read operation is complete.
            if(data.result == CONNERR_CLOSED) {
                printf("Connection closed.\n");
                closeConn();
            } else if(data.result &lt; 0) {
                printf("Read error %i\n", data.result);
                closeConn();
            } else {
                printf("Read %i bytes:\n", data.result);
                // Zero-terminate buffer, so it can be printed.
                mBuffer[data.result] = 0;
                PrintConsole(mBuffer);
                // Read more data.
                maConnRead(mConn, mBuffer, sizeof(mBuffer) - 1);
            }
        }
    }
    void keyPressEvent(int keyCode) {
        if(keyCode == MAK_0)
        maExit(0);
    }
};
extern "C" int MAMain() {
    Moblet::run(new ConnMoblet());
}&nbsp;</pre>
</p>
</body>
</html>
