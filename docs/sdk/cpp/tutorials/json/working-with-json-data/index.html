<html>
<head>
<title>Working with JSON data</title>
</head>
<body>
<h1>Working with JSON data</h1>
<p>I've written a JSON parser. Like the XML parser, it makes calls to your classes to do something useful with the data as it decodes it. Unlike the XML parser, the JSON parser currently requires a complete JSON string, so make sure you've downloaded all the data before you call it. JSON data is typically quite small though. <!--break--></p>

<p>There are six methods you need to implement to use JSON successfully. They are defined as the JSONListener interface</p>

<pre>class JSONListener<br />{<br />  public:<br />    virtual void header(String&amp; header) = 0;<br />    virtual void data(String&amp; value) = 0;<br />    virtual void arrayStart() = 0;<br />    virtual void arrayEnd() = 0;<br />    virtual void objectStart() = 0;<br />    virtual void objectEnd() = 0;<br />};<br /></pre>

<p><br />Each of these is called when the appropriate data is found.  To use the JSON parser, you need to create a class which inherits from JSONListener.  We'll do this shortly.<br /><br />The Code<br /><br />This is the source code for the JSON parser.  It can also be found on the MoSync forum.</p>

<p>JSONParser.h</p>

<pre>/*<br /> * JSONParser.h<br /> *<br /> *  Created on: 21 Feb 2010<br /> *      Author: sjp<br /> */<br /><br />#ifndef JSONPARSER_H_<br />#define JSONPARSER_H_<br /><br />#include &lt;MAUtil/String.h&gt;<br /><br />using namespace MAUtil;<br /><br />class JSONListener<br />{<br />  public:<br />    virtual void header(String&amp; header) = 0;<br />    virtual void data(String&amp; value) = 0;<br />    virtual void arrayStart() = 0;<br />    virtual void arrayEnd() = 0;<br />    virtual void objectStart() = 0;<br />    virtual void objectEnd() = 0;<br /><br />};<br /><br />class JSONParser<br />{<br />  public:<br />    JSONParser();<br />    ~JSONParser();<br /><br />    void parseString(String&amp; jsondata);<br /><br />    void addListener(JSONListener* listener);<br /><br />    void reset();<br />  private:<br />    String data;<br />    String temp;<br />    int _start;<br />    int _end;<br /><br />    Vector&lt;JSONListener*&gt; _listeners;<br />    void parse();<br />    int findNextQuote(int startPos);<br />    int nextDelimiter(int startPos);<br />    int findPosition(char c, int startPos);<br />    bool gotHeader;<br />};<br /><br />#endif /* JSONPARSER_H_ */</pre>

<p><br /><br />JSONParser.cpp</p>

<p> </p>

<pre>JSONParser.cpp<br />/*<br /> * JSONParser.cpp<br /> *<br /> *  Created on: 21 Feb 2010<br /> *      Author: sjp<br /> */<br />#include "JSONParser.h"<br />#include "../std.h"<br /><br />JSONParser::JSONParser()<br />{<br />}<br /><br />JSONParser::~JSONParser()<br />{<br />}<br /><br />void JSONParser::reset()<br />{<br />  _start = 0;<br />  data.clear();<br />  temp.clear();<br />  gotHeader = false;<br />}<br /><br />void JSONParser::parseString(String&amp; jsondata)<br />{<br />  data = jsondata;<br />  _start = 0;<br />  parse();<br />}<br /><br />void JSONParser::parse()<br />{<br />  while(_start &lt; data.length())<br />  {<br />    //Move through white space<br />    char firstChar = data.c_str()[_start];<br /><br />    while(firstChar &lt; 33)<br />      firstChar = data.c_str()[++_start];<br /><br />    //Check the first character, if it is an [,],{ or } raise the approriate event<br /><br />    if(firstChar == '[')<br />    {<br />      Vector_each(JSONListener*, itr, _listeners)<br />        (*itr)-&gt;arrayStart();<br />      _start++;<br />      gotHeader = false;<br />    }<br />    else if(firstChar == ']')<br />    {<br />      Vector_each(JSONListener*, itr, _listeners)<br />        (*itr)-&gt;arrayEnd();<br />      _start++;<br />      gotHeader = false;<br />    }<br />    else if(firstChar == '{')<br />    {<br />      Vector_each(JSONListener*, itr, _listeners)<br />        (*itr)-&gt;objectStart();<br />      _start++;<br />      gotHeader = false;<br />    }<br />    else if(firstChar == '}')<br />    {<br />      Vector_each(JSONListener*, itr, _listeners)<br />        (*itr)-&gt;objectEnd();<br />      _start++;<br />      gotHeader = false;<br />    }<br />    else if(firstChar == ',')<br />    {<br />      _start++;<br />      gotHeader = false;<br />    }<br />    else if(firstChar == ':')<br />    {<br />      _start++;<br />      gotHeader = true;<br />    }<br /><br />    else if(!gotHeader)<br />    {<br />      //read the header<br />      temp.clear();<br />      _end = data.findFirstOf(':', _start);<br /><br />      _end -= _start; //get the length<br />      if(_end &gt; 0)<br />      {<br />        temp = data.substr(_start, _end);<br />        _start += _end;<br />        Vector_each(JSONListener*, itr, _listeners)<br />          (*itr)-&gt;header(temp);<br />      }<br />    }<br />    else<br />    {<br />      //Processing data<br />      if(firstChar == '\"')<br />      {<br />        //Processing a string<br />        _end = findNextQuote(_start + 1) + 1;<br />        _end -= _start;<br />        if(_end &gt; 150)<br />          temp = data.substr(_start + 1, 150); //don't take the leading quote, it won't have a pair<br />        else<br />        {<br />          temp = data.substr(_start, _end);<br />        }<br />        _start += _end;<br />        Vector_each(JSONListener*, itr, _listeners)<br />          (*itr)-&gt;data(temp);<br />      }<br />      else<br />      {<br />        _end = nextDelimiter(_start);<br />        _end -= _start;<br />        temp = data.substr(_start, _end);<br />        _start += _end;<br />        Vector_each(JSONListener*, itr, _listeners)<br />          (*itr)-&gt;data(temp);<br />      }<br />    }<br />  }<br />}<br /><br />int JSONParser::findNextQuote(int startPos)<br />{<br />  startPos = data.findFirstOf('\"', startPos);<br />  if(data.c_str()[startPos-1] == '\\')<br />    startPos = findNextQuote(startPos + 1); //Ignore any \" pairs in the string data<br /><br />    return startPos;<br />}<br /><br /><br />void JSONParser::addListener(JSONListener* listener)<br />{<br />  _listeners.add(listener);<br />}<br /><br />int JSONParser::nextDelimiter(int startPos)<br />{<br />  int nextComma = findPosition(',', startPos);<br />  int nextSquareBrace = findPosition(']', startPos);<br />  int nextCurlyBrace = findPosition('}', startPos);<br /><br />  int lowest = nextComma &lt; nextSquareBrace ? nextComma : nextSquareBrace;<br />  if(nextCurlyBrace &lt; lowest)<br />    lowest = nextCurlyBrace;<br /><br />  return lowest;<br />}<br /><br />int JSONParser::findPosition(char c, int startPos)<br />{<br />  int cpos = data.findFirstOf(c, startPos);<br />  if(cpos == -1)<br />    cpos = data.length();<br /><br />  return cpos;<br />} <br /></pre>

<h2></h2>

<h2>Example application</h2>

<p>Recently, I've wanted to include data from TripSay (www.tripsay.com) into my application.  They have two interfaces which are called by formatting a URL, and putting the request data into the querystring, and returning JSON data.  The first one lets you query their list of locations where they have data, and the second gets the data.</p>

<table border="0">
<tbody>
<tr>
<td><img src="http://docs.google.com/File?id=ddwb2zz_36dtgcx8hr_b" /></td>
<td>
<div id="f.ex" style="text-align: left;">
<div id="mec7" style="text-align: right;"><img src="http://docs.google.com/File?id=ddwb2zz_37xd39vccb_b" /></div>

</div>

</td>
</tr>

</tbody>
</table>

<div id="f.ex" style="text-align: left;"></div>

<p>To work with this data, I've created a screen with an input box which will take the search string, call the TripSay API, download the list of matches as JSON, and then display this list.<br /><br />MapSearchScreen.h</p>

<pre>/*<br /> * MapSearchScreen.h<br /> *<br /> *  Created on: 22 Feb 2010<br /> *      Author: sjp<br /> */<br /><br />#ifndef MAPSEARCHSCREEN_H_<br />#define MAPSEARCHSCREEN_H_<br /><br />#include &lt;MAUI/Screen.h&gt;<br />#include &lt;MAUI/Layout.h&gt;<br />#include &lt;MAUI/Image.h&gt;<br />#include &lt;MAUI/ListBox.h&gt;<br />#include &lt;MAUI/EditBox.h&gt;<br />#include "../Widgets/UIBuilder.h"<br />#include "../Utilities/Util.h"<br />#include "../Widgets/SoftKeyBar.h"<br />#include "../Utilities/JSONParser.h"<br />#include &lt;MAUtil/Downloader.h&gt;<br />#include &lt;MAP/LonLat.h&gt;<br /><br />using namespace MAUI;<br />using namespace MAUtil;<br />using namespace MAP;<br /><br />#define STAGE_UNIQUENAME 0<br />#define STAGE_LAT 1<br />#define STAGE_LON 2<br /><br />class MapSearchScreen : public Screen,<br />                        public ISoftKeyBarListener,<br />                        public JSONListener,<br />                        public DownloadListener<br />{<br />    public:<br />        MapSearchScreen();<br />        ~MapSearchScreen();<br />        void keyPressEvent(int keyCode);<br />        void softKeySelected(int buttonID);<br /><br />        //JSON<br />        void header(String&amp; header);<br />        void data(String&amp; value);<br />        void arrayStart();<br />        void arrayEnd();<br />        void objectStart();<br />        void objectEnd();<br /><br />        //Downloader<br />        void notifyProgress(Downloader* downloader, int downloadedBytes, int totalBytes);<br />        bool outOfMemory(Downloader* downloader);<br />        void finishedDownloading(Downloader* downloader, MAHandle data);<br />        void downloadCancelled(Downloader* downloader);<br />        void error(Downloader* downloader, int code);<br /><br />    private:<br />        Layout* layout;<br />        EditBox* criteria;<br />        Image* image;<br />        ListBox* listBox;<br />        Layout* tab;<br />        JSONParser* jsonparser;<br />        int stage;<br />        int objectCounter;<br />        Downloader* dl;<br />        LonLat* curLonLat;<br />        String encodedUrl;<br />        Vector&lt;LonLat*&gt; locations;<br />};<br /><br />#endif /* MAPSEARCHSCREEN_H_ */</pre>

<p><br />MapSearchScreen.cpp</p>

<pre>/*<br /> * MapSearchScreen.cpp<br /> *<br /> *  Created on: 22 Feb 2010<br /> *      Author: sjp<br /> */<br /><br />#include "MapSearchScreen.h"<br />#include "../std.h"<br />#include "../Utilities/Util.h"<br />#include "../Utilities/Base64.h"<br />#include "MapScreen.h"<br /><br /><br />MapSearchScreen::MapSearchScreen()<br />{<br />  image = (Image*)createMainLayout("search", "back", this);<br />  layout = (Layout*) image-&gt;getChildren()[0];<br />  listBox = (ListBox*) layout-&gt;getChildren()[1];<br /><br />  Label* title = (Label*) layout-&gt;getChildren()[0];<br />  title-&gt;setCaption("Map Search");<br />  this-&gt;setMain(image);<br />  criteria = createEditBox("london", TEXTFIELD);<br />  tab = createTab("Place to search (e.g. Paris)", criteria);<br />  listBox-&gt;add(tab);<br />  criteria-&gt;setSelected(true);<br />  jsonparser = NULL;<br />  dl = NULL;<br /><br />  this-&gt;setMain(image);<br />}<br /><br />MapSearchScreen::~MapSearchScreen()<br />{<br />  if(jsonparser != NULL)<br />    delete jsonparser;<br /><br />  if(dl != NULL)<br />    delete dl;<br />}<br /><br />void MapSearchScreen::softKeySelected(int buttonID)<br />{<br />    switch(buttonID)<br />    {<br />        case SoftKeyBar::LSK:<br />            if(dl-&gt;isDownloading())<br />              return;<br />            if(dl == NULL)<br />            {<br />              dl = new Downloader();<br />              dl-&gt;addDownloadListener(this);<br />            }<br />            objectCounter = 0;<br />            char buffer[200];<br />            char* b = buffer;<br />            sprintf(buffer, "http://www.tripsay.com/api/json/uniqueNames?api_key=8eke83j4&amp;query=%s&amp;maxResults=20", criteria-&gt;getCaption().c_str());<br />            encodedUrl.clear();<br />            LOG("Encoding '%s'", b);<br />            base64_encode(b, strlen(buffer), encodedUrl);<br />            sprintf(buffer, "http://datilo.net/ImageCache/Transcode.aspx?encpath=%s", encodedUrl.c_str());<br />            LOG("Downloading '%s'", buffer);<br />            dl-&gt;beginDownloading(buffer);<br />            break;<br />        case SoftKeyBar::FIRE:<br />            break;<br />        case SoftKeyBar::RSK:<br />            APPCONTROLLER-&gt;back();<br />            break;<br />    }<br />}<br /><br />void MapSearchScreen::keyPressEvent(int keyCode)<br />{<br />  switch(keyCode)<br />  {<br />    case MAK_UP:<br />        listBox-&gt;selectPreviousItem();<br />        break;<br />    case MAK_FIRE:<br />        if(listBox-&gt;getSelectedIndex() &gt; 0)<br />        {<br />          //Set this as the search text<br />          MapScreen* ms = (MapScreen*)APPCONTROLLER-&gt;getScreen(MAPSCREEN);<br />          Label* l = (Label*)listBox-&gt;getChildren()[listBox-&gt;getSelectedIndex()];<br />          curLonLat = locations[listBox-&gt;getSelectedIndex() -1];<br />          ms-&gt;setLocation(*curLonLat);<br />          ms-&gt;setSearchLocation((char*)l-&gt;getCaption().c_str());<br />          APPCONTROLLER-&gt;back();<br />        }<br />        else<br />        {<br />          softKeySelected(SoftKeyBar::LSK);<br />        }<br />        break;<br />    case MAK_DOWN:<br />        listBox-&gt;selectNextItem();<br />        break;<br />  }<br />}<br /><br />//JSON handling<br />void MapSearchScreen::objectEnd()<br />{<br />  objectCounter--;<br />  if(objectCounter == 0)<br />    locations.add(curLonLat);<br />}<br /><br />void MapSearchScreen::objectStart()<br />{<br />  objectCounter++;<br />}<br /><br />void MapSearchScreen::arrayEnd()<br />{}<br /><br />void MapSearchScreen::arrayStart()<br />{}<br /><br />void MapSearchScreen::header(String&amp; header)<br />{<br />  trimQuotes(header);<br /> // LOG("Got header '%s'", header.c_str());<br />  if(strncmp(header.c_str(), "uniqueName", 10) == 0)<br />  {<br />    stage = STAGE_UNIQUENAME;<br />  }<br />  else if(strncmp(header.c_str(), "lng", 3) == 0)<br />  {<br />    stage = STAGE_LON;<br />  }<br />  else if(strncmp(header.c_str(), "lat", 3) == 0)<br />  {<br />    stage = STAGE_LAT;<br />  }<br />  else if(strncmp(header.c_str(), "country", 7) == 0)<br />  {<br />    //New entry<br />    curLonLat = new LonLat();<br />    stage = -1;<br />  }<br />  else<br />  {<br />    stage = -1;<br />  }<br />}<br /><br />void MapSearchScreen::data(String&amp; data)<br />{<br />  switch(stage)<br />  {<br />    case STAGE_UNIQUENAME:<br />      trimQuotes(data);<br />      listBox-&gt;add(createLabel(data));<br />      break;<br />    case STAGE_LAT:<br />      //LOG("Writing Lat '%s'", data.c_str());<br />      curLonLat-&gt;lat = stringToDouble(data);<br />      break;<br />    case STAGE_LON:<br />      //LOG("Writing Lon '%s'", data.c_str());<br />      curLonLat-&gt;lon = stringToDouble(data);<br />      break;<br />  }<br /><br />}<br /><br />//Downloader<br />void MapSearchScreen::downloadCancelled(Downloader* downloader)<br />{}<br /><br />bool MapSearchScreen::outOfMemory(Downloader* downloader)<br />{}<br /><br />void MapSearchScreen::notifyProgress(Downloader* downloader, int d, int t)<br />{<br />  //LOG("Downloaded %d of %d", d, t);<br />}<br /><br />void MapSearchScreen::finishedDownloading(Downloader* downloader, MAHandle data)<br />{<br />  String json;<br />  int size = maGetDataSize(data);<br />  char* jsonchar = new char[size + 1];<br />  maReadData(data, jsonchar, 0, size);<br />  json.append(jsonchar, size);<br /><br />  delete [] jsonchar;<br /><br />  if(jsonparser == NULL)<br />  {<br />    jsonparser = new JSONParser();<br />    jsonparser-&gt;addListener(this);<br />  }<br /> // LOG("Parsing JSON");<br />  jsonparser-&gt;parseString(json);<br />}<br /><br />void MapSearchScreen::error(Downloader* downloader, int code)<br />{<br />  LOG("Error: %d", code);<br />}</pre>

<p><br />To get the JSON data initially in MapSearchScreen, I've also used an MAUtil::Downloader class.  I make the request to the URL (the API key is omitted).  I've also implemented JSONListener.<br /><br />Here is a small section of the JSON the TripSay API returns<br /><br /></p>

<pre>[<br />    {<br />        "country":"FR",<br />        "lat":48.8566,<br />        "lng":2.35097,<br />        "name":"Paris",<br />        "uniqueName":"Paris,Île-de-France,France"<br />    },<br />    {<br />        "country":"US",<br />        "lat":33.67,<br />        "lng":-95.55,<br />        "name":"Paris",<br />        "uniqueName":"Paris,Texas,USA"<br />    },<br />    {<br />        "country":"CA",<br />        "lat":43.2,<br />        "lng":-80.38,<br />        "name":"Paris",<br />        "uniqueName":"Paris,Canada"<br />    }<br />]<br /></pre>

<p>You can see that it gives me an array of object, with [ and ] denoting the array and the { and } denoting the object.  Immediately I can see that I can't simply convert this to XML, as there isn't any root element.  I can also see that whenever I've got as many } tags as {, then I've got a complete object and I can process some data.<br /><br />In my MapSearchScreen code, I've implemented the objectStart and objectEnd methods<br /><br /></p>

<pre>void MapSearchScreen::objectEnd()<br />{<br />  objectCounter--;<br />  if(objectCounter == 0)<br />    locations.add(curLonLat);<br />}<br />void MapSearchScreen::objectStart()<br />{<br />  objectCounter++;<br />}</pre>

<p>So whenever I see { I add one, and whenever I see }, I take one away.  When I've got 0, I know I've completed an object.  By using this technique, the code is robust to take objects inside objects and not start processing at the wrong time.<br /><br />When I read the header, I can set a flag to say what the next piece of data is going to be</p>

<pre>void MapSearchScreen::header(String&amp; header)<br />{<br />  trimQuotes(header);<br />  if(strncmp(header.c_str(), "uniqueName", 10) == 0)<br />    stage = STAGE_UNIQUENAME;<br />  else if(strncmp(header.c_str(), "lng", 3) == 0)<br />    stage = STAGE_LON;<br />  else if(strncmp(header.c_str(), "lat", 3) == 0)<br />    stage = STAGE_LAT;<br />  else if(strncmp(header.c_str(), "country", 7) == 0)<br />  {<br />    //New entry<br />    curLonLat = new LonLat();<br />    stage = -1;<br />  }<br />  else<br />    stage = -1;<br />}</pre>

<p><br />and when I get the data, I can perform the appropriate action<br /><br /></p>

<pre>void MapSearchScreen::data(String&amp; data)<br />{<br />  switch(stage)<br />  {<br />    case STAGE_UNIQUENAME:<br />      trimQuotes(data);<br />      listBox-&gt;add(createLabel(data));<br />      break;<br />    case STAGE_LAT:<br />      curLonLat-&gt;lat = stringToDouble(data);<br />      break;<br />    case STAGE_LON:<br />      curLonLat-&gt;lon = stringToDouble(data);<br />      break;<br />  }<br />}</pre>

<p><br /><br />In this example, I'm not interested in arrayStart and arrayEnd, so I've left them as empty methods.<br /><br /></p>

<pre>void MapSearchScreen::arrayEnd()<br />{}<br /><p><br />void MapSearchScreen::arrayStart() <br />{}</p>
</pre>

<p><br />Whenever I get data for the tag 'uniqueName' I add a label to the listbox, and I save the latitude and longitude data from the JSON.  When the label is selected, I can then pass the latitude and longitude to the map screen, so it can show the correct location.<br /><br />When I show the map, I've got a helper class which turns the JSON data into a UI component, and returns it to the map.<br /><br /></p>

<h2>Summary</h2>

<p>I've gone from hating JSON data to loving it.  This JSON parser is significantly easier to work with than MTXml library, and means I don't have to include the MTXml library if I can have JSON data instead.  If you can live with the restriction that you have to download all the data before you start processing it (and you probably can), then you'll find that the JSON parser probably does everything you need.</p>
</body>
</html>
