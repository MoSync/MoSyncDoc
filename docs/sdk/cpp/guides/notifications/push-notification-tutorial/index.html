<html>
<head>
<!-- <mosyncheadertags>
<meta name="description" content="Push notifications are a useful way to inform users of external events, such as game updates or mail deliveries. In this tutorial we will take you through the steps of creating a simple application that uses the MoSync C++ Notification Library to register and receive push notifications." />
<meta name="dcterms.description" content="Push notifications are a useful way to inform users of external events, such as game updates or mail deliveries. In this tutorial we will take you through the steps of creating a simple application that uses the MoSync C++ Notification Library to register and receive push notifications." />

<title>Push notifications on iOS, Android | MoSync Guide/Tutorial</title>
</mosyncheadertags> -->
</head>
<body>
<h1>Push Notification Handling in C/C++</h1>
<p>Push notifications are a useful way to inform users of external events, such as game updates or mail deliveries. In this tutorial we will take you through the steps of creating a simple application that uses the MoSync <span style="color: #ff0000;"><a href="TEMPLATE_DOC_PATH/sdk/cpp/guides/notifications/using-notification-library/index.html">C++ Notification Library</a></span> to register and receive push notifications.<!--break--><em>&nbsp;</em></p>
<blockquote><p>From MoSync 3.1.1, the Notification API can use the new GCM service. The C2DM service is deprecated, but is still available only for already registered users. The only needed change for the client side now will be supplying the <em>projectId</em> param instead of the <em>senderId</em> when calling<br>NotificationManager::registerPushNotification().</p>
</blockquote>
<p><em><strong>Note 1</strong>: to complete this tutorial you will need a <em>a server-side application</em> and a provisioning profile (for iOS). To create a server side application follow for example <a href="http://mobiforge.com/developing/story/programming-apple-push-notification-services">mobiForge's tutorial</a> for iOS and the <a href="http://developer.android.com/google/gcm/server.html">GCM Server guide</a> for Android.</em></p>
<p><em><strong>Note 2:</strong>: for Android apps, the push notification message sent to GCM must be put inside a JSON object having the key "payload". Read the <a href="#sendingmessage">notes regarding Android</a> for more info.</em></p>
<h2>About push notifications</h2>
<p>Push notifications are messages that are sent by external applications to the device. They allow the user to be notified without needing to open an application. When the device receives a push notification a sound can be played, an application icon badged, or a message can appear on the screen. &nbsp;When the user receives a push notification message, they can launch the appropriate application and see the change or they can choose to ignore the notification.<br><br>Push notifications originate on a remote server—the application provider—and are pushed to applications on devices via a service:</p>
<ul>
<li>on the iOS platform by the <a href="http://developer.apple.com/library/mac/#documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW9">Apple Push Notification service</a>.</li>
</ul>
<ul>
<li>on Android by the <a href="http://developer.android.com/google/gcm/index.html">Google Cloud Messaging for Android</a> service.</li>
</ul>
<h2>MoSync Notification Libraries and APIs</h2>
<p>The MoSync Application Framework provides functions for handling notifications (both push and local) at different layers in your code:</p>
<ul>
<li>Functions in the <a href="http://www.mosync.com/files/imports/doxygen/latest/html5/index.html">Wormhole JavaScript Library</a>,</li>
<li>Classes and methods in the <a href="http://www.mosync.com/files/imports/doxygen/latest/html/group___notification_lib.html">C++ Notifications Library</a>,</li>
<li>Syscalls in the <a href="http://www.mosync.com/files/imports/doxygen/latest/html/group___notification_a_p_i.html">C Notifications API</a>.</li>
</ul>
<p>In this tutorial we will take a look at implementing push notifications in the C/C++ layers.</p>
<h2><a name="creatingpushapp"></a>Creating a push notification application</h2>
<p>Let's create a simple application that sends a push notification, via the application provider, to the device. (The complete listing of this application is given at the end of this tutorial.)<br><br>Start by creating a new NativeUI project:</p>
<ol>
<li>Open the MoSync IDE and select <strong>File </strong>&gt; <strong>New </strong>&gt; <strong>Project</strong>.</li>
<li>Select <strong>MoSync Project</strong> and click <strong>Next</strong>.</li>
<li>Enter a name for your project and click <strong>Next</strong>.</li>
<li>Select the <strong>MoSync NativeUI Project</strong> template and click <strong>Finish</strong>. The template will open in the IDE.<br><br>Now we need to set the application permissions for push notifications so that, on Android devices, we can register and receive Google C2DM messages. (This setting is not required by iOS devices, but as we are creating a cross-platform app we will use it here.)</li>
<li>Right-click on your project in the <strong>Project Explorer</strong> and select <strong>Properties </strong>&gt; <strong>MoSync Project</strong> &gt; <strong>Application Permissions</strong>.</li>
<li>Check the <strong>Push Notifications</strong> box.</li>
<li>Click <strong>OK</strong>.</li>
</ol>
<p>Now we are ready to start coding our application.<br><br>Open the <strong>main.cpp</strong> file in the project, and add the #include directives for the push notification files and the <strong>Notification </strong>namespace:</p>
<pre class="mosync-code-cpp">#include &lt;MAUtil/Moblet.h&gt;
#include &lt;IX_WIDGET.h&gt;

#include &lt;Notification/NotificationManager.h&gt;
#include &lt;Notification/PushNotification.h&gt;
#include &lt;Notification/PushNotificationListener.h&gt;

using namespace MAUtil;
using namespace Notification;</pre>
<p>Add the push notification listener to the <strong>NativeUIMoblet </strong>class:</p>
<pre class="mosync-code-cpp">/**
* Moblet to be used as a template for a Native UI application.
*/
class NativeUIMoblet : public Moblet,
                  public PushNotificationListener
{
</pre>
<p>Inside the Moblet constructor, register the application for receiving push notification events and attach the listener to the service:</p>
<pre class="mosync-code-cpp">NativeUIMoblet() :
    mButtonClickCount(0)
{
    createUI();
    NotificationManager::getInstance()-&gt;registerPushNotification(
            PUSH_NOTIFICATION_TYPE_BADGE |
            PUSH_NOTIFICATION_TYPE_ALERT |
            PUSH_NOTIFICATION_TYPE_SOUND,
            senderID);
    NotificationManager::getInstance()-&gt;addPushNotificationListener(this);
}</pre>
<p>On Android, if registration was not successful due to SERVICE_NOT_AVAILABLE, a registration retry is automatically triggered after 3 seconds.<br><br>There are some differences between platforms:</p>
<ul>
<li>On iOS, the application will be registered as a receiver of push notifications that can contain badges, alerts and sounds. The <strong>senderID </strong>parameter is not used.</li>
<li>On Android, the application will be registered as a receiver of only text notifications. The <strong>senderID</strong> parameter is the identifier of the account that is authorized to send messages to the application. The <strong>senderID</strong> should be set to the <strong>Project Number</strong> obtained from the Google APIs Dashboard (see the <a href="http://developer.android.com/google/gcm/gs.html">Getting Started with GCM</a> guide for more details).</li>
<li>For the old and deprecated Android <strong>C2DM</strong> service, see the <a href="#C2DM%20Registration">C2DM registration notes</a>.</li>
</ul>
<p>Now let’s implement listener’s methods:</p>
<pre class="mosync-code-cpp">//For Android and iOS platforms:
virtual void didReceivePushNotification(PushNotification&amp; pushNotification)
{
maMessageBox("New push notification", pushNotification.getMessage()-&gt;c_str());
}

virtual void didApplicationRegistered(String&amp; token)
{
maMessageBox("Application has registered", token.c_str());
}

virtual void didFaildToRegister(String&amp; error)
{
maMessageBox("Application cannot register", error.c_str());
}

//For the Android platform only (on iOS you will never get the callback):
virtual void didApplicationUnregister()
{
maMessageBox("Application has unregistered","");
}</pre>
<p>In the MoSync IDE, select the <a href="TEMPLATE_DOC_PATH/sdk/tools/guides/ide/using-device-profiles/index.html">target device profile</a> and build the application. MoSync will produce an Xcode project and packages for Android.</p>
<h2>iOS configuration</h2>
<p>Before you build your application for the iOS platform you need to modify the <strong>bundle identifier</strong> in the Xcode project with your provisioning profile.<br><br>First you’ll need to get an application ID from the <a href="http://developer.apple.com/"> Apple Developer Center</a>:</p>
<ol>
<li>At the Apple Developer Center, click the <strong>Member Center</strong> link.</li>
<li>Sign in with your credentials.</li>
<li>Select <strong>iOS Provisioning Portal</strong> &gt; <strong>Provisioning</strong>.</li>
<li>Click on your provisioning profile.</li>
<li>Copy the <strong>App ID</strong> (for example: <em>com.yourcompany.yourProvisioningProfile</em>).</li>
</ol>
<p>Now add the App ID to your project:</p>
<ol>
<li>Open with Xcode the project generated by MoSync.</li>
<li>Select the <strong>Info </strong>tab.</li>
<li>In the <strong>Bundle identifier </strong>value field, paste in the App ID:<br><br class="kix-line-break"><img src="images/Bundle-identifier.png" align="none" width="640" height="194"></li>
</ol>
<h2>Running the application</h2>
<p>First, check that you have followed the <a href="#C2DM%20Prerequisites">prerequisites </a>for running an application.<br>Transfer the application to a device and run it. If the application has been correctly registered for push notifications, a message box will pop up with the device token (on iOS) or the application ID on Android.<br><br>Go to your server-side application and send a push notification for this device token (on iOS) or application ID (on Android). Your application will now receive the notification:</p>
<p><img src="images/pushnotification.png" align="none" width="210" height="314"></p>

<h2><a name="sendingmessage"></a>Note regarding message contents for Android</h2>
For making your Android app receive push notification messages, the JSON data sent to GCM must contain the key "payload". The following JSON code is an example of what should be sent to your app through GCM:
<pre class="mosync-code-cpp">
{
  "registration_ids" : ["APA91bHun4MxP5egoKMwt2KZFBaFUH-1RYqx..."],
  "data" : {
    "payload" : {
        "test" : "everything in the payload object will be received by MoSync's Android runtime",
        "msg" : "This key-value pair will also be received."
    }
  },
}
</pre>
<p>The example is based on the information given under <a href="http://developer.android.com/google/gcm/gcm.html#request">Request format</a> in the GCM Architectural Overview. This page can also be consulted regarding how to test sending push notifications to your Android app using e.g. a REST client.</p>

<h2><a name="C2DM Registration"></a>Notes about the old C2DM service</h2>
<p>If you are using the deprecated C2DM service, see the <a href="https://developers.google.com/android/c2dm/">Android Cloud to Device Messaging Framework</a> guide. Regarding <strong>senderID</strong> see the <a href="https://developers.google.com/android/c2dm/#registering">Registering for C2DM</a> section. For information regarding how to send messages to the application, see the section <a href="https://developers.google.com/android/c2dm/#push">How the Application Server Sends Messages</a>.</p>
<p>The <strong>senderID</strong> parameter should be used in the call to registerPushNotification. The <strong>senderID</strong> is used in to identify an Android application that is permitted to send messages to the device. This ID is typically role-based rather than being a personal account—- for example, <em>my-app@gmail.com.</em>.</p>
<p>When the mobile application wants to use C2DM it first registers with Google and gets a unique registration ID, which is different than senderID. The registration ID is tied to a particular application running on a particular device. You must send that ID to your servers and store it so you can communicate with the user.</p>
<p>It is recommended that the application registers with Google C2DM only the first time it’s launched, and then stores the registration ID for later use. Note however that Google may periodically refresh the registration ID, so you should design your application with the understanding that the registration request may be called multiple times. Your application needs to be able to respond accordingly. The registration ID lasts until the application explicitly unregisters itself, or until Google refreshes the registration ID for your application. Uninstalling the application also has the effect of unregistering.</p>

<h2>main.cpp</h2>
<p>Here is a complete listing of our application:</p>
<pre class="mosync-code-cpp">#include &lt;ma.h&gt;
#include &lt;mavsprintf.h&gt;
#include &lt;MAUtil/Moblet.h&gt;
#include &lt;IX_WIDGET.h&gt;

#include "notification/NotificationManager.h"
#include "notification/PushNotification.h"
#include "notification/PushNotificationListener.h"

using namespace MAUtil;
using Notification::NotificationManager;
using Notification::PushNotification;
using Notification::PushNotificationListener;

#define C2DM_USER_ACCOUNT "yourAccountHere"

/**
* Moblet to be used as a template for a Native UI application.
*/
class NativeUIMoblet : public Moblet,
                       public PushNotificationListener
{
public:
    /**
     * The constructor creates the user interface.
     */
    NativeUIMoblet() :
        mButtonClickCount(0)
    {
        createUI();
        NotificationManager::getInstance()-&gt;registerPushNotification(
                Notification::PUSH_NOTIFICATION_TYPE_BADGE |
                Notification::PUSH_NOTIFICATION_TYPE_ALERT |
                Notification::PUSH_NOTIFICATION_TYPE_SOUND,
                C2DM_USER_ACCOUNT);
        NotificationManager::getInstance()-&gt;addPushNotificationListener(this);
    }

    /**
     * Create the user interface.
     */
    void createUI()
    {
        // Create a NativeUI screen that will hold layout and widgets.
        MAHandle screen = maWidgetCreate(MAW_SCREEN);

        // Error handling for devices that do not support NativeUI.
        if (-1 == screen)
        {
            maPanic(0, "NativeUI is only available on Android and iOS.");
        }

        // Create a layout object.
        MAHandle layout = maWidgetCreate(MAW_VERTICAL_LAYOUT);
        widgetSetPropertyInt(
            layout,
            MAW_WIDGET_WIDTH,
            MAW_CONSTANT_FILL_AVAILABLE_SPACE);
        widgetSetPropertyInt(
            layout,
            MAW_WIDGET_HEIGHT,
            MAW_CONSTANT_FILL_AVAILABLE_SPACE);
        maWidgetSetProperty(
            layout,
            MAW_WIDGET_BACKGROUND_COLOR,
             "0xFFFFFF");
        maWidgetAddChild(screen, layout);

        // Create a button.
        mButton = maWidgetCreate(MAW_BUTTON);
        widgetSetPropertyInt(
            mButton,
            MAW_WIDGET_WIDTH,
            MAW_CONSTANT_FILL_AVAILABLE_SPACE);
        widgetSetPropertyInt(
            mButton,
            MAW_WIDGET_HEIGHT,
             MAW_CONSTANT_WRAP_CONTENT);
        maWidgetSetProperty(
            mButton,
            MAW_BUTTON_TEXT_VERTICAL_ALIGNMENT,
            MAW_ALIGNMENT_CENTER);
        maWidgetSetProperty(
            mButton,
            MAW_BUTTON_TEXT_HORIZONTAL_ALIGNMENT,
            MAW_ALIGNMENT_CENTER);
        maWidgetSetProperty(
            mButton,
            MAW_BUTTON_TEXT,
            "Click me!");
        maWidgetSetProperty(
            mButton,
            MAW_BUTTON_FONT_COLOR,
            "0x000000");
        maWidgetSetProperty(
            mButton,
            MAW_BUTTON_FONT_SIZE,
            "36");
        maWidgetAddChild(layout, mButton);

        // Show the screen.
        maWidgetScreenShow(screen);

        // Make the Moblet listen to widget events.
        Environment::getEnvironment().addCustomEventListener(this);
    }

    /**
     * Called when a key is pressed.
     */
    void keyPressEvent(int keyCode, int nativeCode)
    {
        if (MAK_BACK == keyCode || MAK_0 == keyCode)
        {
            // Call close to exit the application.
            close();
        }
    }

    /**
     * Method that implements the custom event listener interface.
     * Widget events are sent as custom events.
     */
    void customEvent(const MAEvent&amp; event)
    {
        if (EVENT_TYPE_WIDGET == event.type)
         {
            // Get the widget event data structure.
            MAWidgetEventData* widgetEvent = (MAWidgetEventData*) event.data;

            // Has the button been clicked?
            if (MAW_EVENT_CLICKED == widgetEvent-&gt;eventType &amp;&amp;
                mButton == widgetEvent-&gt;widgetHandle)
            {
                ++mButtonClickCount;
                char buffer[256];
                if (1 == mButtonClickCount)
                {
                    sprintf(buffer, "You clicked me once!", mButtonClickCount);
                }
                else
                if (100 == mButtonClickCount)
                {
                    sprintf(buffer, "Wow! 100 times!", mButtonClickCount);
                }
                else
                {
                    sprintf(buffer, "You clicked me %i times!", mButtonClickCount);
                 }
                maWidgetSetProperty(mButton, "text", buffer);
            }
        }
    }

    /**
     * Helper method for setting a widget property integer value.
     */
    int widgetSetPropertyInt(MAHandle handle, const char *property, int value)
    {
        char buffer[256];
        sprintf(buffer, "%i", value);
        maWidgetSetProperty(handle, property, buffer);
    }

   /**
    * Called when the application receives a push notification.
    * @param pushNotification The received push notification.
    */
   virtual void didReceivePushNotification(
       PushNotification&amp; pushNotification)
   {
       maMessageBox("New push notification", pushNotification.getMessage()-&gt;c_str());
   }

   /**
    * Called when application has been registered for push notification.
    */
   virtual void didApplicationRegistered(MAUtil::String&amp; token)
   {
       maMessageBox("Application has registered", token.c_str());
   }

   /**
    * Called if the application did not registered for push notification.
    */
   virtual void didFaildToRegister(
       const int code,
       MAUtil::String&amp; error)
   {
       maMessageBox("Application cannot register", error.c_str());
   }
private:
    MAHandle mButton;
    int mButtonClickCount;
};

/**
* Main function that is called when the program starts.
*/
extern "C" int MAMain()
{
    Moblet::run(new NativeUIMoblet());
    return 0;
}</pre>
</body>
</html>
